{"ast":null,"code":"var React = require('react');\n\nvar Map = require('immutable').Map;\n\nfunction applyKeysToObject(obj, other) {\n  for (var key in other) {\n    obj[key] = other[key];\n  }\n}\n\nfunction mergeStateAndProps(state, props) {\n  var finalProps = {};\n  applyKeysToObject(finalProps, state);\n  applyKeysToObject(finalProps, props);\n  return finalProps;\n}\n\nfunction notEqual(next, prev) {\n  if (next === prev) {\n    return false;\n  }\n\n  if (typeof next !== 'object' || next === null || typeof prev !== 'object' || prev === null) {\n    return true;\n  }\n\n  if (Object.keys(next).length !== Object.keys(prev).length) {\n    return true;\n  }\n\n  for (var key in next) {\n    if (next[key] !== prev[key]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction createConnectedComponent(mapStateToProps, Component, store) {\n  if (typeof mapStateToProps !== 'function') {\n    throw new Error('Map state to props must be a function.');\n  }\n\n  return React.createClass({\n    displayName: 'ConnectedComponent',\n    shouldComponentUpdate: function (nextProps, nextState) {\n      return notEqual(nextProps, this.props) || notEqual(nextState, this.state);\n    },\n    updateState: function () {\n      const state = mapStateToProps(store.getState());\n\n      if (typeof state !== 'object' || state === null) {\n        throw new Error('Map state to props function must return an object.');\n      }\n\n      this.setState(state);\n    },\n    componentWillMount: function () {\n      this.updateState();\n      store.addListener(this.updateState);\n    },\n    componentWillUnmount: function () {\n      store.removeListener(this.updateState);\n    },\n    render: function () {\n      return React.createElement(Component, mergeStateAndProps(this.state, this.props));\n    }\n  });\n}\n\nmodule.exports = function Store(actions) {\n  var store = this;\n  var state = Map();\n  var listeners = [];\n  var actionChain = [];\n  var actionInProgress = false;\n  store.actions = {};\n\n  function createAction(callback) {\n    return function () {\n      var dispatchArgs = Array.prototype.slice.call(arguments);\n      actionChain.push(function () {\n        return callback.apply(store, [state].concat(dispatchArgs));\n      });\n\n      while (!actionInProgress && actionChain.length) {\n        actionInProgress = true;\n        state = actionChain.shift()();\n\n        for (var i = 0; i < listeners.length; i += 1) {\n          listeners[i]();\n        }\n\n        actionInProgress = false;\n      }\n    };\n  }\n\n  for (var key in actions) {\n    store.actions[key] = createAction(actions[key]);\n  }\n\n  store.addListener = function (callback) {\n    listeners.push(callback);\n  };\n\n  store.removeListener = function (callback) {\n    var index = listeners.indexOf(callback);\n\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n  };\n\n  store.getState = function () {\n    return state;\n  };\n\n  store.map = function (mapStateToProps) {\n    return {\n      to: function (Component) {\n        return createConnectedComponent(mapStateToProps, Component, store);\n      }\n    };\n  };\n};","map":{"version":3,"sources":["D:/react/net/project1/node_modules/redax/lib/index.js"],"names":["React","require","Map","applyKeysToObject","obj","other","key","mergeStateAndProps","state","props","finalProps","notEqual","next","prev","Object","keys","length","createConnectedComponent","mapStateToProps","Component","store","Error","createClass","displayName","shouldComponentUpdate","nextProps","nextState","updateState","getState","setState","componentWillMount","addListener","componentWillUnmount","removeListener","render","createElement","module","exports","Store","actions","listeners","actionChain","actionInProgress","createAction","callback","dispatchArgs","Array","prototype","slice","call","arguments","push","apply","concat","shift","i","index","indexOf","splice","map","to"],"mappings":"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","sourcesContent":["var React = require('react');\nvar Map = require('immutable').Map;\n\nfunction applyKeysToObject (obj, other) {\n  for (var key in other) {\n    obj[key] = other[key];\n  }\n}\n\nfunction mergeStateAndProps (state, props) {\n  var finalProps = {};\n\n  applyKeysToObject(finalProps, state);\n  applyKeysToObject(finalProps, props);\n\n  return finalProps;\n}\n\nfunction notEqual (next, prev) {\n  if (next === prev) {\n    return false;\n  }\n\n  if (typeof next !== 'object' || next === null || typeof prev !== 'object' || prev === null) {\n    return true;\n  }\n\n  if (Object.keys(next).length !== Object.keys(prev).length) {\n    return true;\n  }\n\n  for (var key in next) {\n    if (next[key] !== prev[key]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction createConnectedComponent (mapStateToProps, Component, store) {\n  if (typeof mapStateToProps !== 'function') {\n    throw new Error('Map state to props must be a function.');\n  }\n\n  return React.createClass({\n    displayName: 'ConnectedComponent',\n\n    shouldComponentUpdate: function (nextProps, nextState) {\n      return notEqual(nextProps, this.props) || notEqual(nextState, this.state);\n    },\n\n    updateState: function () {\n      const state = mapStateToProps(store.getState());\n\n      if (typeof state !== 'object' || state === null) {\n        throw new Error('Map state to props function must return an object.');\n      }\n\n      this.setState(state);\n    },\n\n    componentWillMount: function () {\n      this.updateState();\n      store.addListener(this.updateState);\n    },\n\n    componentWillUnmount: function () {\n      store.removeListener(this.updateState);\n    },\n\n    render: function () {\n      return React.createElement(Component, mergeStateAndProps(this.state, this.props));\n    }\n  });\n}\n\nmodule.exports = function Store (actions) {\n  var store = this;\n  var state = Map();\n  var listeners = [];\n  var actionChain = [];\n  var actionInProgress = false;\n\n  store.actions = {};\n\n  function createAction (callback) {\n    return function () {\n      var dispatchArgs = Array.prototype.slice.call(arguments);\n\n      actionChain.push(function () {\n        return callback.apply(store, [state].concat(dispatchArgs));\n      });\n\n      while (!actionInProgress && actionChain.length) {\n        actionInProgress = true;\n        state = actionChain.shift()();\n\n        for (var i = 0; i < listeners.length; i += 1) {\n          listeners[i]();\n        }\n\n        actionInProgress = false;\n      }\n    };\n  }\n\n  for (var key in actions) {\n    store.actions[key] = createAction(actions[key]);\n  }\n\n  store.addListener = function (callback) {\n    listeners.push(callback);\n  };\n\n  store.removeListener = function (callback) {\n    var index = listeners.indexOf(callback);\n\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n  };\n\n  store.getState = function () {\n    return state;\n  };\n\n  store.map = function (mapStateToProps) {\n    return {\n      to: function (Component) {\n        return createConnectedComponent(mapStateToProps, Component, store);\n      }\n    };\n  };\n};\n"]},"metadata":{},"sourceType":"script"}